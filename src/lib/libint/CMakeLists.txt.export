cmake_minimum_required(VERSION 3.16)  # 3.16: unity build
                                      # 3.15: new Python detection
                                      # 3.8: introduced C++ standards as features
cmake_policy(SET CMP0074 NEW)
cmake_policy(SET CMP0077 NEW)
cmake_policy(SET CMP0079 NEW)

############################# Version and Metadata #############################

list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules)
include(int_computed)

project(
  Libint2
  VERSION ${LIBINT_VERSION}
  DESCRIPTION ${LIBINT_DESCRIPTION}
  HOMEPAGE_URL "http://libint.valeyev.net"
  LANGUAGES CXX
  )

set(${PROJECT_NAME}_AUTHORS "Edward F. Valeev")
set(${PROJECT_NAME}_LICENSE "LGPL-3.0-only")

set(L2 Libint2)  # Namespace
set(pnv libint2) # projectnameversion

#################################### Guide #####################################

# See "TARBALL" labels in INSTALL.md for elaboration of options, dependencies, & targets.

################################### Options ####################################
include(options)
include(CheckFunctionExists)

#  <<<  General  >>>

option_with_default(CMAKE_BUILD_TYPE "Build type" Release)
option_with_print(LIBINT2_ENABLE_MPFR
  "Use GNU MPFR library for high-precision testing (requires MPFR. EXPERTS ONLY)" OFF)
option_with_print(LIBINT2_ENABLE_PYTHON
  "Build Python bindings (requires Python and Pybind11 and Eigen3)" OFF)
option_with_print(LIBINT2_PREFIX_PYTHON_INSTALL
  "For LIBINT2_ENABLE_PYTHON=ON, whether to install the Python module in the Linux manner to CMAKE_INSTALL_PREFIX or to not install it. See target libint2-python-wheel for alternate installation in the Python manner to Python_EXECUTABLE's site-packages." OFF)
option_with_print(LIBINT2_LOCAL_Eigen3_INSTALL
  "Install an exported target with hard-coded Eigen3 dependency paths. This is potentially useful and important when consuming the compiled C++11 interface library so that the Libint library build and Libint consumer build use the same Eigen3 installation & ABI. This is at most a convenience when consuming the header-only C++11 interface library. In consumer build, set `LIBINT2_LOCAL_Eigen3_FIND=ON` before `find_package(Libint2) to load the exported Eigen3." OFF)
option_with_print(CMAKE_DISABLE_FIND_PACKAGE_Boost
  "When Boost required for C++11 API, disable its detection, thereby forcing use of bundled Boost (Standard CMake variable: https://cmake.org/cmake/help/latest/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html)" OFF)


check_function_exists(posix_memalign HAVE_POSIX_MEMALIGN)
if (HAVE_POSIX_MEMALIGN)
    option_with_default(LIBINT2_ALIGN_SIZE
      "(EXPERT) if posix_memalign is available, this will specify alignment of Libint data, in units of sizeof(LIBINT2_REALTYPE). Default is to use built-in heuristics." 0)
    mark_as_advanced(LIBINT2_ALIGN_SIZE)
endif()

option_with_default(LIBINT2_REALTYPE
  "Specifies the floating-point data type used by the library." double)
include(int_userreal)


#  <<<  Ordering Conventions  >>>

# Jan 2023, retired  # option_with_default(LIBINT2_SHGAUSS_ORDERING ...
# August 2023: the following variable has an effect on `INT_SOLIDHARMINDEX(l, m)` but otherwise the choice can be deferred to runtime.
set(LIBINT2_SHGAUSS_ORDERING ${LIBINT2_SHGAUSS_ORDERING})
message(STATUS "Setting option LIBINT2_SHGAUSS_ORDERING: ${LIBINT2_SHGAUSS_ORDERING} (read-only from generation-time)")

set(LIBINT2_CARTGAUSS_ORDERING ${LIBINT2_CARTGAUSS_ORDERING})
message(STATUS "Setting option LIBINT2_CARTGAUSS_ORDERING: ${LIBINT2_CARTGAUSS_ORDERING} (read-only from generation-time)")

set(LIBINT2_SHELL_SET ${LIBINT2_SHELL_SET})
message(STATUS "Setting option LIBINT2_SHELL_SET: ${LIBINT2_SHELL_SET} (read-only from generation-time)")


######################## Process & Validate Options ###########################
include(autocmake_safeguards)


################################## Dependencies #################################

# See notes at https://github.com/evaleev/libint/blob/master/INSTALL.md#prerequisites

if (LIBINT2_ENABLE_MPFR)
    find_package(Multiprecision MODULE REQUIRED COMPONENTS gmpxx mpfr)
    set(LIBINT_HAS_MPFR 1)

    get_property(_loc TARGET Multiprecision::gmp PROPERTY LOCATION)
    message(VERBOSE "${Cyan}Found GMP${ColourReset}: ${_loc}")
    get_property(_loc TARGET Multiprecision::gmpxx PROPERTY LOCATION)
    message(VERBOSE "${Cyan}Found GMPXX${ColourReset}: ${_loc}")
    get_property(_loc TARGET Multiprecision::mpfr PROPERTY LOCATION)
    message(VERBOSE "${Cyan}Found MPFR${ColourReset}: ${_loc} (found version ${MPFR_VERSION})")
endif()

#if (LIBINT2_REQUIRE_CXX_API)
    if (NOT TARGET Boost::headers)
        find_package(Boost 1.57)
    endif()
    if (TARGET Boost::headers)
        include(int_checkboost)
        set(LIBINT_HAS_SYSTEM_BOOST_PREPROCESSOR_VARIADICS 1)
    else()
        set(LIBINT_HAS_SYSTEM_BOOST_PREPROCESSOR_VARIADICS 0)

        file(MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/include/libint2)
        execute_process(
          COMMAND ${CMAKE_COMMAND} -E tar xzf ${PROJECT_SOURCE_DIR}/external/boost.tar.gz
          WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/include/libint2
          RESULT_VARIABLE UNPACK_BOOST_RESULT
          OUTPUT_VARIABLE UNPACK_BOOST_OUTPUT
          ERROR_VARIABLE UNPACK_BOOST_OUTPUT
          )
        message(STATUS "Unpacking bundled Boost")
        if (NOT UNPACK_BOOST_RESULT EQUAL 0)
            message(FATAL_ERROR "Failed to unpack the bundled Boost! The tar command output:\n${UNPACK_BOOST_OUTPUT}")
        endif()
    endif()
#endif()

find_package(Eigen3 MODULE)

if (TARGET Eigen3::Eigen)
    set(LIBINT_HAS_EIGEN 1)
endif()
#if (LIBINT2_REQUIRE_CXX_API AND NOT ${LIBINT_HAS_CXX_API})
if (NOT LIBINT_HAS_EIGEN)  # TODO tmp wrong logic
    message(FATAL_ERROR "C++ API cannot be built without Eigen3; configure (via CMake) and install Eigen3 and add the install prefix to CMAKE_PREFIX_PATH, or add -DLIBINT2_REQUIRE_CXX_API=OFF to the CMake command line if the C++ API is not required")
endif()

# Python is optionally used for testing.
# * But for Fortran, it's additionally required for preprocessing.
# * And for Python bindings, it's required along with its headers.
if (LIBINT2_ENABLE_PYTHON)
    find_package(Python COMPONENTS Interpreter Development REQUIRED)
elseif (LIBINT2_ENABLE_FORTRAN)
    find_package(Python COMPONENTS Interpreter REQUIRED)
else()
    find_package(Python COMPONENTS Interpreter)
endif()


################################# Main Project #################################
include(CMakePackageConfigHelpers)

configure_file(
  include/libint2/config2.h.cmake.in
  include/libint2/config2.h
  @ONLY)
# configuration.cc defines a string summary of capabilities. @ONLY is maximally
#   deferred in case config2 changes the summary (as it used to when
#   LIBINT_SHGSHELL_ORDERING was library-config-time selected).
configure_file(
  src/configuration.cc.cmake.in
  src/configuration.cc
  @ONLY)

configure_package_config_file(
  cmake/${pnv}-config.cmake.in
  "${CMAKE_CURRENT_BINARY_DIR}/${pnv}-config.cmake"
  INSTALL_DESTINATION "lib/cmake/libint2" # TODO ${LIBINT2_INSTALL_CMAKEDIR}
  NO_SET_AND_CHECK_MACRO
  )

#  <<<  Install  >>>

install(
  DIRECTORY
    ${PROJECT_SOURCE_DIR}/include2/  # TODO temp for skeleton
  TYPE INCLUDE
  COMPONENT ${L2}_Development
  FILES_MATCHING
    PATTERN "*.h"
    PATTERN "*.hpp"
  )

if (LIBINT2_LOCAL_Eigen3_INSTALL AND TARGET Eigen3::Eigen)

    add_library(Eigen INTERFACE)
    foreach(prop
      INTERFACE_INCLUDE_DIRECTORIES
      INTERFACE_COMPILE_DEFINITIONS
      INTERFACE_COMPILE_OPTIONS
      INTERFACE_LINK_LIBRARIES
      INTERFACE_POSITION_INDEPENDENT_CODE
      )
        get_property(_propval TARGET Eigen3::Eigen PROPERTY ${prop})
        set_property(TARGET Eigen PROPERTY ${prop} ${_propval})
    endforeach()

    install(
      TARGETS
        Eigen
      EXPORT local_set
      LIBRARY
        COMPONENT ${L2}_Eigen3
        NAMELINK_COMPONENT ${L2}_Eigen3
      ARCHIVE
        COMPONENT ${L2}_Eigen3
      PUBLIC_HEADER
        COMPONENT ${L2}_Eigen3
      )
endif()

#  <<<  Export Config  >>>

if (LIBINT2_LOCAL_Eigen3_INSTALL AND TARGET Eigen3::Eigen)
    install(
      EXPORT local_set
      FILE "${pnv}-targets-eigen3.cmake"
      NAMESPACE "${L2}::"
      DESTINATION ${LIBINT2_INSTALL_CMAKEDIR}
      COMPONENT ${L2}_Eigen3
      )
endif()
